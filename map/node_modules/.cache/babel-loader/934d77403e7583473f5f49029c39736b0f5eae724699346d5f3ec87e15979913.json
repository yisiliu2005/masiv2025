{"ast":null,"code":"var _jsxFileName = \"/Users/yisiliu/development/MASIV2025InternTest/map/src/components/ThreeViewer.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport * as THREE from 'three';\nimport './ThreeViewer.css';\n\n/**\n * Three.js 3D city dashboard viewer\n * Renders buildings as extruded geometries and handles interaction\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ThreeViewer = ({\n  buildings,\n  highlightedIds,\n  selectedId,\n  onBuildingClick\n}) => {\n  _s();\n  const containerRef = useRef(null);\n  const sceneRef = useRef(null);\n  const cameraRef = useRef(null);\n  const rendererRef = useRef(null);\n  const buildingMeshesRef = useRef({});\n  const raycasterRef = useRef(new THREE.Raycaster());\n  const mouseRef = useRef(new THREE.Vector2());\n\n  // Color constants\n  const COLOR_DEFAULT = 0x6699cc;\n  const COLOR_HIGHLIGHTED = 0xffaa00;\n  const COLOR_SELECTED = 0xff0000;\n  const COLOR_DIMMED = 0x445566;\n\n  // Calculate bounds for the scene\n  const calculateBounds = buildings => {\n    if (buildings.length === 0) {\n      return {\n        minLat: 0,\n        maxLat: 0,\n        minLon: 0,\n        maxLon: 0,\n        centerLat: 0,\n        centerLon: 0\n      };\n    }\n    let minLat = Infinity,\n      maxLat = -Infinity;\n    let minLon = Infinity,\n      maxLon = -Infinity;\n    buildings.forEach(b => {\n      minLat = Math.min(minLat, b.latitude);\n      maxLat = Math.max(maxLat, b.latitude);\n      minLon = Math.min(minLon, b.longitude);\n      maxLon = Math.max(maxLon, b.longitude);\n    });\n    const centerLat = (maxLat + minLat) / 2;\n    const centerLon = (maxLon + minLon) / 2;\n    return {\n      minLat,\n      maxLat,\n      minLon,\n      maxLon,\n      centerLat,\n      centerLon\n    };\n  };\n\n  // Convert lat/lon to 3D position (centered and scaled)\n  const latLonTo3D = (lat, lon, bounds) => {\n    // Center coordinates\n    const latCentered = lat - bounds.centerLat;\n    const lonCentered = lon - bounds.centerLon;\n\n    // Scale to scene units (approx meters)\n    const scale = 111000; // meters per degree at this latitude\n    const x = lonCentered * scale * 0.63; // 0.63 = cos(51°) for longitude correction\n    const z = -latCentered * scale; // negate for north-up\n\n    return new THREE.Vector3(x, 0, z);\n  };\n\n  // Create a building mesh\n  const createBuildingMesh = (building, bounds) => {\n    if (!building.footprint || building.footprint.length === 0) {\n      return null;\n    }\n    try {\n      // Footprint is GeoJSON polygon coordinates [longitude, latitude]\n      const coordinates = building.footprint[0]; // First ring of polygon\n\n      // Create shape from coordinates\n      const shape = new THREE.Shape();\n      coordinates.forEach((coord, i) => {\n        const [lon, lat] = coord;\n        const pos = latLonTo3D(lat, lon, bounds);\n        if (i === 0) {\n          shape.moveTo(pos.x, pos.z);\n        } else {\n          shape.lineTo(pos.x, pos.z);\n        }\n      });\n      shape.closePath();\n\n      // Create extruded geometry; extrude along Y after rotation\n      const rawHeight = Math.max(building.height || 12, 10);\n      const extrusionHeight = rawHeight * 0.6; // scale up vertical exaggeration\n      const geometry = new THREE.ExtrudeGeometry(shape, {\n        depth: extrusionHeight,\n        bevelEnabled: false\n      });\n\n      // Rotate so extrusion goes up the Y axis and lift to ground level\n      geometry.rotateX(Math.PI / 2);\n      geometry.translate(0, extrusionHeight / 2, 0);\n\n      // Create material - UNIQUE for each building\n      const material = new THREE.MeshPhongMaterial({\n        color: COLOR_DEFAULT,\n        emissive: 0x000000,\n        side: THREE.DoubleSide\n      });\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.userData.buildingId = building.id;\n      mesh.userData.building = building;\n      mesh.castShadow = true;\n      mesh.receiveShadow = true;\n      return mesh;\n    } catch (error) {\n      console.error('Error creating building mesh:', error);\n      return null;\n    }\n  };\n\n  // Initialize Three.js scene\n  const initScene = () => {\n    if (!containerRef.current) return;\n\n    // Clear any existing canvases first\n    while (containerRef.current.firstChild) {\n      containerRef.current.removeChild(containerRef.current.firstChild);\n    }\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0xcccccc);\n    sceneRef.current = scene;\n\n    // Camera setup\n    const width = containerRef.current.clientWidth;\n    const height = containerRef.current.clientHeight;\n    const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 2000);\n    camera.position.set(-5, 180, 100);\n    camera.lookAt(3, -300, -100);\n    cameraRef.current = camera;\n\n    // Renderer setup\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true\n    });\n    renderer.setSize(width, height);\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = THREE.PCFShadowMap;\n    containerRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Lighting\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n    scene.add(ambientLight);\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    directionalLight.position.set(120, 180, 80);\n    directionalLight.castShadow = true;\n    directionalLight.shadow.mapSize.width = 1024;\n    directionalLight.shadow.mapSize.height = 1024;\n    scene.add(directionalLight);\n\n    // Ground plane\n    const groundGeometry = new THREE.PlaneGeometry(360, 360);\n    const groundMaterial = new THREE.MeshLambertMaterial({\n      color: 0xbbbbbb\n    });\n    const ground = new THREE.Mesh(groundGeometry, groundMaterial);\n    ground.rotation.x = -Math.PI / 2;\n    ground.receiveShadow = true;\n    scene.add(ground);\n\n    // Test cube for animation loop verification\n    const testCubeGeometry = new THREE.BoxGeometry(10, 10, 10);\n    const testCubeMaterial = new THREE.MeshPhongMaterial({\n      color: 0xff00ff\n    });\n    const testCube = new THREE.Mesh(testCubeGeometry, testCubeMaterial);\n    testCube.position.set(0, 50, 0);\n    scene.add(testCube);\n\n    // Handle window resize\n    const handleResize = () => {\n      var _containerRef$current, _containerRef$current2;\n      const newWidth = ((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.clientWidth) || width;\n      const newHeight = ((_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.clientHeight) || height;\n      camera.aspect = newWidth / newHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(newWidth, newHeight);\n    };\n    window.addEventListener('resize', handleResize);\n\n    // Animation loop - always render to capture material updates\n    let isAnimating = true;\n    const animate = () => {\n      if (isAnimating) {\n        requestAnimationFrame(animate);\n      }\n\n      // Rotate test cube\n      testCube.rotation.x += 0.01;\n      testCube.rotation.y += 0.01;\n      renderer.render(scene, camera);\n    };\n    animate();\n    return () => {\n      isAnimating = false;\n      window.removeEventListener('resize', handleResize);\n    };\n  };\n\n  // Initialize on mount\n  useEffect(() => {\n    const cleanup = initScene();\n    return cleanup;\n  }, []);\n\n  // Rebuild meshes when buildings data changes\n  useEffect(() => {\n    if (!sceneRef.current || buildings.length === 0) return;\n\n    // Remove old meshes\n    Object.values(buildingMeshesRef.current).forEach(mesh => {\n      sceneRef.current.remove(mesh);\n      mesh.geometry.dispose();\n      if (Array.isArray(mesh.material)) {\n        mesh.material.forEach(m => m.dispose());\n      } else {\n        mesh.material.dispose();\n      }\n    });\n    buildingMeshesRef.current = {};\n    const bounds = calculateBounds(buildings);\n    buildings.forEach(building => {\n      const mesh = createBuildingMesh(building, bounds);\n      if (mesh) {\n        sceneRef.current.add(mesh);\n        buildingMeshesRef.current[building.id] = mesh;\n      }\n    });\n  }, [buildings]);\n\n  // Update building colors based on highlights\n  useEffect(() => {\n    console.log('Color update effect triggered. highlightedIds:', highlightedIds, 'selectedId:', selectedId);\n    console.log('Building meshes count:', Object.keys(buildingMeshesRef.current).length);\n    Object.entries(buildingMeshesRef.current).forEach(([buildingId, mesh]) => {\n      let color = COLOR_DEFAULT;\n      if (selectedId === buildingId) {\n        color = COLOR_SELECTED;\n      } else if (highlightedIds && highlightedIds.includes(buildingId)) {\n        color = COLOR_HIGHLIGHTED;\n      } else if (highlightedIds && highlightedIds.length > 0) {\n        color = COLOR_DIMMED; // Dim non-matching buildings\n      }\n\n      // Clone material and set new color\n      const oldMaterial = mesh.material;\n      mesh.material = new THREE.MeshPhongMaterial({\n        color: color,\n        emissive: 0x000000,\n        side: THREE.DoubleSide\n      });\n      oldMaterial.dispose();\n      console.log(`Building ${buildingId}: color set to 0x${color.toString(16)}`);\n    });\n    console.log('Color update complete');\n  }, [highlightedIds, selectedId]);\n\n  // Handle clicks on buildings\n  useEffect(() => {\n    const handleWindowClick = event => {\n      // Only process canvas clicks\n      if (event.target.tagName !== 'CANVAS') {\n        return;\n      }\n      const rect = event.target.getBoundingClientRect();\n      mouseRef.current.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n      mouseRef.current.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n      raycasterRef.current.setFromCamera(mouseRef.current, cameraRef.current);\n      const intersects = raycasterRef.current.intersectObjects(Object.values(buildingMeshesRef.current));\n      if (intersects.length > 0) {\n        const building = intersects[0].object.userData.building;\n        onBuildingClick(building);\n      }\n    };\n    window.addEventListener('click', handleWindowClick, false);\n    return () => window.removeEventListener('click', handleWindowClick, false);\n  }, [onBuildingClick]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    className: \"three-viewer\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 297,\n    columnNumber: 10\n  }, this);\n};\n_s(ThreeViewer, \"64alPRPQtuAXC3NTBYk29alAafU=\");\n_c = ThreeViewer;\nexport default ThreeViewer;\nvar _c;\n$RefreshReg$(_c, \"ThreeViewer\");","map":{"version":3,"names":["React","useEffect","useRef","THREE","jsxDEV","_jsxDEV","ThreeViewer","buildings","highlightedIds","selectedId","onBuildingClick","_s","containerRef","sceneRef","cameraRef","rendererRef","buildingMeshesRef","raycasterRef","Raycaster","mouseRef","Vector2","COLOR_DEFAULT","COLOR_HIGHLIGHTED","COLOR_SELECTED","COLOR_DIMMED","calculateBounds","length","minLat","maxLat","minLon","maxLon","centerLat","centerLon","Infinity","forEach","b","Math","min","latitude","max","longitude","latLonTo3D","lat","lon","bounds","latCentered","lonCentered","scale","x","z","Vector3","createBuildingMesh","building","footprint","coordinates","shape","Shape","coord","i","pos","moveTo","lineTo","closePath","rawHeight","height","extrusionHeight","geometry","ExtrudeGeometry","depth","bevelEnabled","rotateX","PI","translate","material","MeshPhongMaterial","color","emissive","side","DoubleSide","mesh","Mesh","userData","buildingId","id","castShadow","receiveShadow","error","console","initScene","current","firstChild","removeChild","scene","Scene","background","Color","width","clientWidth","clientHeight","camera","PerspectiveCamera","position","set","lookAt","renderer","WebGLRenderer","antialias","setSize","shadowMap","enabled","type","PCFShadowMap","appendChild","domElement","ambientLight","AmbientLight","add","directionalLight","DirectionalLight","shadow","mapSize","groundGeometry","PlaneGeometry","groundMaterial","MeshLambertMaterial","ground","rotation","testCubeGeometry","BoxGeometry","testCubeMaterial","testCube","handleResize","_containerRef$current","_containerRef$current2","newWidth","newHeight","aspect","updateProjectionMatrix","window","addEventListener","isAnimating","animate","requestAnimationFrame","y","render","removeEventListener","cleanup","Object","values","remove","dispose","Array","isArray","m","log","keys","entries","includes","oldMaterial","toString","handleWindowClick","event","target","tagName","rect","getBoundingClientRect","clientX","left","clientY","top","setFromCamera","intersects","intersectObjects","object","ref","className","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/yisiliu/development/MASIV2025InternTest/map/src/components/ThreeViewer.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport * as THREE from 'three';\nimport './ThreeViewer.css';\n\n/**\n * Three.js 3D city dashboard viewer\n * Renders buildings as extruded geometries and handles interaction\n */\nconst ThreeViewer = ({ buildings, highlightedIds, selectedId, onBuildingClick }) => {\n  const containerRef = useRef(null);\n  const sceneRef = useRef(null);\n  const cameraRef = useRef(null);\n  const rendererRef = useRef(null);\n  const buildingMeshesRef = useRef({});\n  const raycasterRef = useRef(new THREE.Raycaster());\n  const mouseRef = useRef(new THREE.Vector2());\n\n  // Color constants\n  const COLOR_DEFAULT = 0x6699cc;\n  const COLOR_HIGHLIGHTED = 0xffaa00;\n  const COLOR_SELECTED = 0xff0000;\n  const COLOR_DIMMED = 0x445566;\n\n  // Calculate bounds for the scene\n  const calculateBounds = (buildings) => {\n    if (buildings.length === 0) {\n      return { minLat: 0, maxLat: 0, minLon: 0, maxLon: 0, centerLat: 0, centerLon: 0 };\n    }\n\n    let minLat = Infinity, maxLat = -Infinity;\n    let minLon = Infinity, maxLon = -Infinity;\n\n    buildings.forEach((b) => {\n      minLat = Math.min(minLat, b.latitude);\n      maxLat = Math.max(maxLat, b.latitude);\n      minLon = Math.min(minLon, b.longitude);\n      maxLon = Math.max(maxLon, b.longitude);\n    });\n\n    const centerLat = (maxLat + minLat) / 2;\n    const centerLon = (maxLon + minLon) / 2;\n\n    return { minLat, maxLat, minLon, maxLon, centerLat, centerLon };\n  };\n\n  // Convert lat/lon to 3D position (centered and scaled)\n  const latLonTo3D = (lat, lon, bounds) => {\n    // Center coordinates\n    const latCentered = lat - bounds.centerLat;\n    const lonCentered = lon - bounds.centerLon;\n\n    // Scale to scene units (approx meters)\n    const scale = 111000; // meters per degree at this latitude\n    const x = lonCentered * scale * 0.63; // 0.63 = cos(51°) for longitude correction\n    const z = -latCentered * scale; // negate for north-up\n\n    return new THREE.Vector3(x, 0, z);\n  };\n\n  // Create a building mesh\n  const createBuildingMesh = (building, bounds) => {\n    if (!building.footprint || building.footprint.length === 0) {\n      return null;\n    }\n\n    try {\n      // Footprint is GeoJSON polygon coordinates [longitude, latitude]\n      const coordinates = building.footprint[0]; // First ring of polygon\n\n      // Create shape from coordinates\n      const shape = new THREE.Shape();\n\n      coordinates.forEach((coord, i) => {\n        const [lon, lat] = coord;\n        const pos = latLonTo3D(lat, lon, bounds);\n\n        if (i === 0) {\n          shape.moveTo(pos.x, pos.z);\n        } else {\n          shape.lineTo(pos.x, pos.z);\n        }\n      });\n      shape.closePath();\n\n      // Create extruded geometry; extrude along Y after rotation\n      const rawHeight = Math.max(building.height || 12, 10);\n      const extrusionHeight = rawHeight * 0.6; // scale up vertical exaggeration\n      const geometry = new THREE.ExtrudeGeometry(shape, {\n        depth: extrusionHeight,\n        bevelEnabled: false,\n      });\n\n      // Rotate so extrusion goes up the Y axis and lift to ground level\n      geometry.rotateX(Math.PI / 2);\n      geometry.translate(0, extrusionHeight / 2, 0);\n\n      // Create material - UNIQUE for each building\n      const material = new THREE.MeshPhongMaterial({\n        color: COLOR_DEFAULT,\n        emissive: 0x000000,\n        side: THREE.DoubleSide,\n      });\n\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.userData.buildingId = building.id;\n      mesh.userData.building = building;\n      mesh.castShadow = true;\n      mesh.receiveShadow = true;\n\n      return mesh;\n    } catch (error) {\n      console.error('Error creating building mesh:', error);\n      return null;\n    }\n  };\n\n  // Initialize Three.js scene\n  const initScene = () => {\n    if (!containerRef.current) return;\n\n    // Clear any existing canvases first\n    while (containerRef.current.firstChild) {\n      containerRef.current.removeChild(containerRef.current.firstChild);\n    }\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0xcccccc);\n    sceneRef.current = scene;\n\n    // Camera setup\n    const width = containerRef.current.clientWidth;\n    const height = containerRef.current.clientHeight;\n    const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 2000);\n    camera.position.set(-5, 180, 100); \n    camera.lookAt(3, -300, -100); \n    cameraRef.current = camera;\n\n    // Renderer setup\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(width, height);\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = THREE.PCFShadowMap;\n    containerRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Lighting\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n    scene.add(ambientLight);\n\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    directionalLight.position.set(120, 180, 80);\n    directionalLight.castShadow = true;\n    directionalLight.shadow.mapSize.width = 1024;\n    directionalLight.shadow.mapSize.height = 1024;\n    scene.add(directionalLight);\n\n    // Ground plane\n    const groundGeometry = new THREE.PlaneGeometry(360, 360);\n    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xbbbbbb });\n    const ground = new THREE.Mesh(groundGeometry, groundMaterial);\n    ground.rotation.x = -Math.PI / 2;\n    ground.receiveShadow = true;\n    scene.add(ground);\n\n    // Test cube for animation loop verification\n    const testCubeGeometry = new THREE.BoxGeometry(10, 10, 10);\n    const testCubeMaterial = new THREE.MeshPhongMaterial({ color: 0xff00ff });\n    const testCube = new THREE.Mesh(testCubeGeometry, testCubeMaterial);\n    testCube.position.set(0, 50, 0);\n    scene.add(testCube);\n\n\n    // Handle window resize\n    const handleResize = () => {\n      const newWidth = containerRef.current?.clientWidth || width;\n      const newHeight = containerRef.current?.clientHeight || height;\n      camera.aspect = newWidth / newHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(newWidth, newHeight);\n    };\n    window.addEventListener('resize', handleResize);\n\n    // Animation loop - always render to capture material updates\n    let isAnimating = true;\n    const animate = () => {\n      if (isAnimating) {\n        requestAnimationFrame(animate);\n      }\n      \n      // Rotate test cube\n      testCube.rotation.x += 0.01;\n      testCube.rotation.y += 0.01;\n      \n      renderer.render(scene, camera);\n    };\n    animate();\n\n    return () => {\n      isAnimating = false;\n      window.removeEventListener('resize', handleResize);\n    };\n  };\n\n  // Initialize on mount\n  useEffect(() => {\n    const cleanup = initScene();\n    return cleanup;\n  }, []);\n\n  // Rebuild meshes when buildings data changes\n  useEffect(() => {\n    if (!sceneRef.current || buildings.length === 0) return;\n\n    // Remove old meshes\n    Object.values(buildingMeshesRef.current).forEach((mesh) => {\n      sceneRef.current.remove(mesh);\n      mesh.geometry.dispose();\n      if (Array.isArray(mesh.material)) {\n        mesh.material.forEach((m) => m.dispose());\n      } else {\n        mesh.material.dispose();\n      }\n    });\n    buildingMeshesRef.current = {};\n\n    const bounds = calculateBounds(buildings);\n\n    buildings.forEach((building) => {\n      const mesh = createBuildingMesh(building, bounds);\n      if (mesh) {\n        sceneRef.current.add(mesh);\n        buildingMeshesRef.current[building.id] = mesh;\n      }\n    });\n  }, [buildings]);\n\n  // Update building colors based on highlights\n  useEffect(() => {\n    console.log('Color update effect triggered. highlightedIds:', highlightedIds, 'selectedId:', selectedId);\n    console.log('Building meshes count:', Object.keys(buildingMeshesRef.current).length);\n    \n    Object.entries(buildingMeshesRef.current).forEach(([buildingId, mesh]) => {\n      let color = COLOR_DEFAULT;\n\n      if (selectedId === buildingId) {\n        color = COLOR_SELECTED;\n      } else if (highlightedIds && highlightedIds.includes(buildingId)) {\n        color = COLOR_HIGHLIGHTED;\n      } else if (highlightedIds && highlightedIds.length > 0) {\n        color = COLOR_DIMMED; // Dim non-matching buildings\n      }\n\n      // Clone material and set new color\n      const oldMaterial = mesh.material;\n      mesh.material = new THREE.MeshPhongMaterial({\n        color: color,\n        emissive: 0x000000,\n        side: THREE.DoubleSide,\n      });\n      oldMaterial.dispose();\n      \n      console.log(`Building ${buildingId}: color set to 0x${color.toString(16)}`);\n    });\n    \n    console.log('Color update complete');\n  }, [highlightedIds, selectedId]);\n\n  // Handle clicks on buildings\n  useEffect(() => {\n    const handleWindowClick = (event) => {\n      // Only process canvas clicks\n      if (event.target.tagName !== 'CANVAS') {\n        return;\n      }\n\n      const rect = event.target.getBoundingClientRect();\n      mouseRef.current.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n      mouseRef.current.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n      raycasterRef.current.setFromCamera(mouseRef.current, cameraRef.current);\n\n      const intersects = raycasterRef.current.intersectObjects(\n        Object.values(buildingMeshesRef.current)\n      );\n\n      if (intersects.length > 0) {\n        const building = intersects[0].object.userData.building;\n        onBuildingClick(building);\n      }\n    };\n\n    window.addEventListener('click', handleWindowClick, false);\n    return () => window.removeEventListener('click', handleWindowClick, false);\n  }, [onBuildingClick]);\n\n  return <div ref={containerRef} className=\"three-viewer\" />;\n};\n\nexport default ThreeViewer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}