{"ast":null,"code":"/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;\n!function (undefined) {\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n  function configure(conf) {\n    if (conf) {\n      this._conf = conf;\n      conf.delimiter && (this.delimiter = conf.delimiter);\n      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this.newListener = conf.newListener);\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n  function EventEmitter(conf) {\n    this._events = {};\n    this.newListener = false;\n    configure.call(this, conf);\n  }\n\n  //\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i) {\n    if (!tree) {\n      return [];\n    }\n    var listeners = [],\n      leaf,\n      len,\n      branch,\n      xTree,\n      xxTree,\n      isolatedBranch,\n      endReached,\n      typeLength = type.length,\n      currentType = type[i],\n      nextType = type[i + 1];\n    if (i === typeLength && tree._listeners) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (typeof tree._listeners === 'function') {\n        handlers && handlers.push(tree._listeners);\n        return [tree];\n      } else {\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n          handlers && handlers.push(tree._listeners[leaf]);\n        }\n        return [tree];\n      }\n    }\n    if (currentType === '*' || currentType === '**' || tree[currentType]) {\n      //\n      // If the event emitted is '*' at this part\n      // or there is a concrete match at this patch\n      //\n      if (currentType === '*') {\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 1));\n          }\n        }\n        return listeners;\n      } else if (currentType === '**') {\n        endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === '*';\n        if (endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n        }\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            if (branch === '*' || branch === '**') {\n              if (tree[branch]._listeners && !endReached) {\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n              }\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            } else if (branch === nextType) {\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 2));\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            }\n          }\n        }\n        return listeners;\n      }\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i + 1));\n    }\n    xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i + 1);\n    }\n    xxTree = tree['**'];\n    if (xxTree) {\n      if (i < typeLength) {\n        if (xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        for (branch in xxTree) {\n          if (branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n            if (branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i + 2);\n            } else if (branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i + 1);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, {\n                '**': isolatedBranch\n              }, i + 1);\n            }\n          }\n        }\n      } else if (xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength);\n      } else if (xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n      }\n    }\n    return listeners;\n  }\n  function growListenerTree(type, listener) {\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    for (var i = 0, len = type.length; i + 1 < len; i++) {\n      if (type[i] === '**' && type[i + 1] === '**') {\n        return;\n      }\n    }\n    var tree = this.listenerTree;\n    var name = type.shift();\n    while (name) {\n      if (!tree[name]) {\n        tree[name] = {};\n      }\n      tree = tree[name];\n      if (type.length === 0) {\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        } else if (typeof tree._listeners === 'function') {\n          tree._listeners = [tree._listeners, listener];\n        } else if (isArray(tree._listeners)) {\n          tree._listeners.push(listener);\n          if (!tree._listeners.warned) {\n            var m = defaultMaxListeners;\n            if (typeof this._events.maxListeners !== 'undefined') {\n              m = this._events.maxListeners;\n            }\n            if (m > 0 && tree._listeners.length > m) {\n              tree._listeners.warned = true;\n              console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', tree._listeners.length);\n              console.trace();\n            }\n          }\n        }\n        return true;\n      }\n      name = type.shift();\n    }\n    return true;\n  }\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n  EventEmitter.prototype.setMaxListeners = function (n) {\n    this._events || init.call(this);\n    this._events.maxListeners = n;\n    if (!this._conf) this._conf = {};\n    this._conf.maxListeners = n;\n  };\n  EventEmitter.prototype.event = '';\n  EventEmitter.prototype.once = function (event, fn) {\n    this.many(event, 1, fn);\n    return this;\n  };\n  EventEmitter.prototype.many = function (event, ttl, fn) {\n    var self = this;\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      fn.apply(this, arguments);\n    }\n    listener._origin = fn;\n    this.on(event, listener);\n    return self;\n  };\n  EventEmitter.prototype.emit = function () {\n    this._events || init.call(this);\n    var type = arguments[0];\n    if (type === 'newListener' && !this.newListener) {\n      if (!this._events.newListener) {\n        return false;\n      }\n    }\n\n    // Loop through the *_all* functions and invoke them.\n    if (this._all) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        this._all[i].apply(this, args);\n      }\n    }\n\n    // If there is no 'error' event listener then throw.\n    if (type === 'error') {\n      if (!this._all && !this._events.error && !(this.wildcard && this.listenerTree.error)) {\n        if (arguments[1] instanceof Error) {\n          throw arguments[1]; // Unhandled 'error' event\n        } else {\n          throw new Error(\"Uncaught, unspecified 'error' event.\");\n        }\n        return false;\n      }\n    }\n    var handler;\n    if (this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n    }\n    if (typeof handler === 'function') {\n      this.event = type;\n      if (arguments.length === 1) {\n        handler.call(this);\n      } else if (arguments.length > 1) switch (arguments.length) {\n        case 2:\n          handler.call(this, arguments[1]);\n          break;\n        case 3:\n          handler.call(this, arguments[1], arguments[2]);\n          break;\n        // slower\n        default:\n          var l = arguments.length;\n          var args = new Array(l - 1);\n          for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n          handler.apply(this, args);\n      }\n      return true;\n    } else if (handler) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n      var listeners = handler.slice();\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        this.event = type;\n        listeners[i].apply(this, args);\n      }\n      return listeners.length > 0 || !!this._all;\n    } else {\n      return !!this._all;\n    }\n  };\n  EventEmitter.prototype.on = function (type, listener) {\n    if (typeof type === 'function') {\n      this.onAny(type);\n      return this;\n    }\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    this.emit('newListener', type, listener);\n    if (this.wildcard) {\n      growListenerTree.call(this, type, listener);\n      return this;\n    }\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    } else if (typeof this._events[type] === 'function') {\n      // Adding the second element, need to change to array.\n      this._events[type] = [this._events[type], listener];\n    } else if (isArray(this._events[type])) {\n      // If we've already got an array, just append.\n      this._events[type].push(listener);\n\n      // Check for listener leak\n      if (!this._events[type].warned) {\n        var m = defaultMaxListeners;\n        if (typeof this._events.maxListeners !== 'undefined') {\n          m = this._events.maxListeners;\n        }\n        if (m > 0 && this._events[type].length > m) {\n          this._events[type].warned = true;\n          console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);\n          console.trace();\n        }\n      }\n    }\n    return this;\n  };\n  EventEmitter.prototype.onAny = function (fn) {\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n    if (!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    this._all.push(fn);\n    return this;\n  };\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n  EventEmitter.prototype.off = function (type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n    var handlers,\n      leafs = [];\n    if (this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n    } else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({\n        _listeners: handlers\n      });\n    }\n    for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n        var position = -1;\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {\n            position = i;\n            break;\n          }\n        }\n        if (position < 0) {\n          continue;\n        }\n        if (this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        } else {\n          this._events[type].splice(position, 1);\n        }\n        if (handlers.length === 0) {\n          if (this.wildcard) {\n            delete leaf._listeners;\n          } else {\n            delete this._events[type];\n          }\n        }\n        return this;\n      } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {\n        if (this.wildcard) {\n          delete leaf._listeners;\n        } else {\n          delete this._events[type];\n        }\n      }\n    }\n    return this;\n  };\n  EventEmitter.prototype.offAny = function (fn) {\n    var i = 0,\n      l = 0,\n      fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for (i = 0, l = fns.length; i < l; i++) {\n        if (fn === fns[i]) {\n          fns.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._all = [];\n    }\n    return this;\n  };\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n  EventEmitter.prototype.removeAllListeners = function (type) {\n    if (arguments.length === 0) {\n      !this._events || init.call(this);\n      return this;\n    }\n    if (this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n      for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {\n        var leaf = leafs[iLeaf];\n        leaf._listeners = null;\n      }\n    } else {\n      if (!this._events[type]) return this;\n      this._events[type] = null;\n    }\n    return this;\n  };\n  EventEmitter.prototype.listeners = function (type) {\n    if (this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers;\n    }\n    this._events || init.call(this);\n    if (!this._events[type]) this._events[type] = [];\n    if (!isArray(this._events[type])) {\n      this._events[type] = [this._events[type]];\n    }\n    return this._events[type];\n  };\n  EventEmitter.prototype.listenersAny = function () {\n    if (this._all) {\n      return this._all;\n    } else {\n      return [];\n    }\n  };\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(function () {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    exports.EventEmitter2 = EventEmitter;\n  } else {\n    // Browser global.\n    window.EventEmitter2 = EventEmitter;\n  }\n}();","map":{"version":3,"names":["undefined","isArray","Array","_isArray","obj","Object","prototype","toString","call","defaultMaxListeners","init","_events","_conf","configure","conf","delimiter","maxListeners","wildcard","newListener","listenerTree","EventEmitter","searchListenerTree","handlers","type","tree","i","listeners","leaf","len","branch","xTree","xxTree","isolatedBranch","endReached","typeLength","length","currentType","nextType","_listeners","push","hasOwnProperty","concat","growListenerTree","listener","split","slice","name","shift","warned","m","console","error","trace","setMaxListeners","n","event","once","fn","many","ttl","self","Error","off","apply","arguments","_origin","on","emit","_all","l","args","handler","ns","onAny","addListener","leafs","iLeaf","position","splice","offAny","fns","removeListener","removeAllListeners","listenersAny","define","amd","exports","EventEmitter2","window"],"sources":["/Users/yisiliu/development/MASIV2025InternTest/map/node_modules/eventemitter2/lib/eventemitter2.js"],"sourcesContent":["/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this.newListener = conf.newListener);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this.newListener = false;\n    configure.call(this, conf);\n  }\n\n  //\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i) {\n    if (!tree) {\n      return [];\n    }\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\n    if (i === typeLength && tree._listeners) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (typeof tree._listeners === 'function') {\n        handlers && handlers.push(tree._listeners);\n        return [tree];\n      } else {\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n          handlers && handlers.push(tree._listeners[leaf]);\n        }\n        return [tree];\n      }\n    }\n\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\n      //\n      // If the event emitted is '*' at this part\n      // or there is a concrete match at this patch\n      //\n      if (currentType === '*') {\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\n          }\n        }\n        return listeners;\n      } else if(currentType === '**') {\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\n        if(endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n        }\n\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            if(branch === '*' || branch === '**') {\n              if(tree[branch]._listeners && !endReached) {\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n              }\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            } else if(branch === nextType) {\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            }\n          }\n        }\n        return listeners;\n      }\n\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\n    }\n\n    xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i+1);\n    }\n\n    xxTree = tree['**'];\n    if(xxTree) {\n      if(i < typeLength) {\n        if(xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        for(branch in xxTree) {\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n            if(branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\n            } else if(branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\n            }\n          }\n        }\n      } else if(xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength);\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener) {\n\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    for(var i = 0, len = type.length; i+1 < len; i++) {\n      if(type[i] === '**' && type[i+1] === '**') {\n        return;\n      }\n    }\n\n    var tree = this.listenerTree;\n    var name = type.shift();\n\n    while (name) {\n\n      if (!tree[name]) {\n        tree[name] = {};\n      }\n\n      tree = tree[name];\n\n      if (type.length === 0) {\n\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        }\n        else if(typeof tree._listeners === 'function') {\n          tree._listeners = [tree._listeners, listener];\n        }\n        else if (isArray(tree._listeners)) {\n\n          tree._listeners.push(listener);\n\n          if (!tree._listeners.warned) {\n\n            var m = defaultMaxListeners;\n\n            if (typeof this._events.maxListeners !== 'undefined') {\n              m = this._events.maxListeners;\n            }\n\n            if (m > 0 && tree._listeners.length > m) {\n\n              tree._listeners.warned = true;\n              console.error('(node) warning: possible EventEmitter memory ' +\n                            'leak detected. %d listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit.',\n                            tree._listeners.length);\n              console.trace();\n            }\n          }\n        }\n        return true;\n      }\n      name = type.shift();\n    }\n    return true;\n  }\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    this._events || init.call(this);\n    this._events.maxListeners = n;\n    if (!this._conf) this._conf = {};\n    this._conf.maxListeners = n;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn) {\n    this.many(event, 1, fn);\n    return this;\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    this.on(event, listener);\n\n    return self;\n  };\n\n  EventEmitter.prototype.emit = function() {\n\n    this._events || init.call(this);\n\n    var type = arguments[0];\n\n    if (type === 'newListener' && !this.newListener) {\n      if (!this._events.newListener) { return false; }\n    }\n\n    // Loop through the *_all* functions and invoke them.\n    if (this._all) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        this._all[i].apply(this, args);\n      }\n    }\n\n    // If there is no 'error' event listener then throw.\n    if (type === 'error') {\n\n      if (!this._all &&\n        !this._events.error &&\n        !(this.wildcard && this.listenerTree.error)) {\n\n        if (arguments[1] instanceof Error) {\n          throw arguments[1]; // Unhandled 'error' event\n        } else {\n          throw new Error(\"Uncaught, unspecified 'error' event.\");\n        }\n        return false;\n      }\n    }\n\n    var handler;\n\n    if(this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    }\n    else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      if (arguments.length === 1) {\n        handler.call(this);\n      }\n      else if (arguments.length > 1)\n        switch (arguments.length) {\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n          // slower\n          default:\n            var l = arguments.length;\n            var args = new Array(l - 1);\n            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n            handler.apply(this, args);\n        }\n      return true;\n    }\n    else if (handler) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\n      var listeners = handler.slice();\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        this.event = type;\n        listeners[i].apply(this, args);\n      }\n      return (listeners.length > 0) || !!this._all;\n    }\n    else {\n      return !!this._all;\n    }\n\n  };\n\n  EventEmitter.prototype.on = function(type, listener) {\n\n    if (typeof type === 'function') {\n      this.onAny(type);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    this.emit('newListener', type, listener);\n\n    if(this.wildcard) {\n      growListenerTree.call(this, type, listener);\n      return this;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    }\n    else if(typeof this._events[type] === 'function') {\n      // Adding the second element, need to change to array.\n      this._events[type] = [this._events[type], listener];\n    }\n    else if (isArray(this._events[type])) {\n      // If we've already got an array, just append.\n      this._events[type].push(listener);\n\n      // Check for listener leak\n      if (!this._events[type].warned) {\n\n        var m = defaultMaxListeners;\n\n        if (typeof this._events.maxListeners !== 'undefined') {\n          m = this._events.maxListeners;\n        }\n\n        if (m > 0 && this._events[type].length > m) {\n\n          this._events[type].warned = true;\n          console.error('(node) warning: possible EventEmitter memory ' +\n                        'leak detected. %d listeners added. ' +\n                        'Use emitter.setMaxListeners() to increase limit.',\n                        this._events[type].length);\n          console.trace();\n        }\n      }\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if(!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    this._all.push(fn);\n    return this;\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n    }\n    else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n      }\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function(type) {\n    if (arguments.length === 0) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n        var leaf = leafs[iLeaf];\n        leaf._listeners = null;\n      }\n    }\n    else {\n      if (!this._events[type]) return this;\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function(type) {\n    if(this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers;\n    }\n\n    this._events || init.call(this);\n\n    if (!this._events[type]) this._events[type] = [];\n    if (!isArray(this._events[type])) {\n      this._events[type] = [this._events[type]];\n    }\n    return this._events[type];\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  if (typeof define === 'function' && define.amd) {\n     // AMD. Register as an anonymous module.\n    define(function() {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    exports.EventEmitter2 = EventEmitter;\n  }\n  else {\n    // Browser global.\n    window.EventEmitter2 = EventEmitter;\n  }\n}();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}